# b00tl3gRSA3

Platform: picoCTF

## Description

> Let's decrypt this: ciphertext? Something seems a bit small.
>*(AUTHOR: SPEEEDAY/DANNY)*

`ciphertext:`

```bash
N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125 
```

## Solution

We get these value by connecting to the service,

```bash
┌──(meld㉿meld)-[~]
└─$ nc jupiter.challenges.picoctf.org 51575
c: 107033843928600811037230044901555101977571488744454421184009340780252103612298314853608842564175893094602522781434347364236639678614190587625760712444613810662855427770209190986735296158706058093268815611804669598220580001495098019774565231028866495912458595561501625538819116187582405125369024408111265413938376743595641478387520854786845848582
n: 355572156260172788125205037161401274334574166314737774199401308084340105944597050733754657026007717787827490544184021350581590675209023418615643959627432881355375862498421791173322335391813303412152579688971336677501644542226096492374225895588332246494580216729746993796385447604704883696595441535739706452862031023084763774338616302287807084911
e: 65537
```

When we try to factorize the `n` using [factordb](http://factordb.com/), it can be seen that there are more than 2 factors. Anyway, we can still calculate the `phi`. The easier method is using [alpertron](https://www.alpertron.com.ar/ECM.HTM) that can find the `phi` directly. Now, we easily get the `d` by computing the modular multiplicative inverse of `e` modulo `phi`.

`Solver.py:`

```python
from Crypto.Util.number import long_to_bytes

c = 107033843928600811037230044901555101977571488744454421184009340780252103612298314853608842564175893094602522781434347364236639678614190587625760712444613810662855427770209190986735296158706058093268815611804669598220580001495098019774565231028866495912458595561501625538819116187582405125369024408111265413938376743595641478387520854786845848582
n = 355572156260172788125205037161401274334574166314737774199401308084340105944597050733754657026007717787827490544184021350581590675209023418615643959627432881355375862498421791173322335391813303412152579688971336677501644542226096492374225895588332246494580216729746993796385447604704883696595441535739706452862031023084763774338616302287807084911
e = 65537

# https://www.alpertron.com.ar/ECM.HTM
phi = 355572155357043461903438558869119999423053050895222679528633832777171961842698206012901518457968900459994939658853616522978692154747870090752127199881959276159475098780926920783293532244442509351031924970469786818222929013665639668794860891829284802851846961500549829078699118150539080752585637443371495743568506248031296745914761216000000000000

d = pow(e, -1, phi)

m = pow(c, d, n)
print('d', d)
print('m', m)
print(long_to_bytes(m))
```

**flag:** `picoCTF{too_many_fact0rs_0731311}`
